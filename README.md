# pyhon_DataStructure

## 1.1 时间复杂度
### 若a+b+c=1000,且a^2+b^2=c^2(a,b,c为自然数)，如何求出所有a、b、c的组合？两种解法的程序执行时间差别巨大
### 机器执行时间=基本运算数量*每个基本步骤执行的时间
### 时间复杂度:假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=0(g()),则称(n)为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)
### 例如：枚举法中有三个for循环，每个for循环执行次数是1000次，if执行1次，print执行一次，则T(n)=N^3+2。
### 时间复杂度的几条基本计算规则
#### 1.基本操作，即只有常数项，认为其时间复杂度为0(1)
#### 2.顺序结构，时间复杂度按加法进行计算
#### 3.循环结构，时间复杂度按乘法进行计算
#### 4.分支结构，时间复杂度取最大值
#### 5.判断-个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
#### 6.在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度
### 时间复杂度比较：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
### 函数是对基本步骤的封装，其复杂度要看函数体里面的基本操作数，例如比较list.append()和list.insert()的时间效率。
## 1.2 Python内置类型性能分析
### timeit模块
### timeit模块可以用来测试一小段Python代码的执行速度。
### class timeit. Timer(stmt='pass', setup='pass', timer= <timer function>)
### Timer是测量小段代码执行速度的类。
### stmt参数是要测试的代码语句(statment) ;
### setup参数是运行代码时需要的设置;
### timer参数是一个定时器函数， 与平台有关。
### timeit.Timer.timeit(number=1000000)
### Timer类中测试语句执行速度的对象方法。number参 数是测试代码时的测试次数，默认为1000000次。 方法
### 返回执行代码的平均耗时，一个float类 型的秒数。
### list内置操作的时间复杂度


| Operation | Big-O Efficiency|
| ------ | ------ |
| indexx[] | O(1) |
| index assignment | O(1) |
| append | O(1)|
| popO | O(1) |
| pop(i) | O(n)|
| insert(i,item)| O(n)|
| del operator | O(n)|
| iteration | O(n)|
| contains (in) | O(n)|
| get slice [x:) | O(k)|
| del slice | O(n)|
| set slice | O(n+ k)|
| reverse | O(n)|
| concatenate | O(k)|
| sort | O(n logn)|
| multiply | O(nk)

### dict内置操作的时间复杂度
| Operation | Big-O Efficiency|
| ------ | ------ |
|  copy| O(n)|
| get item| 0(1)|
| set item| O(1)|
| delete item| O(1)|
| contains (in)| O(1) |

## 1.3。3 引入数据结构
### 1.3.1数据结构与算法的区别
#### 1.数据结构只是静态的描述了数据元素之间的关系。
#### 2.高效的程序需要在数据结构的基础上设计和选择算法。
#### 3.程序=数据结构+算法
#### 4.总结:算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体

## 1.3.2抽象数据类型(Abstract Data Type)
### 抽象数据类型(ADT)的含义是指一个数学模型以及定义在此数学模型上的-一组操作。即把数据类型和数据类型上的运算捆在一起，进行封装。引入抽象数据类型的目的是把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。
### 最常用的数据运算有五种:
#### ●插入
#### ●删除
#### ●修改
#### ●查找
#### ●排序
## 1.3.3内存、类型本质、连续存储
### 内存：用来存放数据，cpu读取，由存储单元组成。内存的基本单位是字节。1字节=8位
### 如果存放一个整型数据，要占多少个存储单元？对于一个32位的计算机，一个基本整型数据int a= 1占用4个字节,存放在计算机中以二进制形式000000001存放

## 02 顺序表

### 2.1 顺序表的形式

### 2.2顺序表的结构与实现
### 2.2.1 两种存储方式
1. 一体式存储：存储表信息的单元与元素存储区以连续的方式安排在一块存储区里， 两部分数据的整体形成一个完整的顺序表对象。
2. 分离式结构：表对象里只保存与整个表有关的信息(即容量和元素个数)，实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。
### 2.2.2 元素存储区替换
一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺
序表对象(指存储顺序表的结构信息的区域)改变了。
分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。
### 2.2.3 元素存储区扩充
采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数
据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境(计算机系统)还有空闲存
储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表,
因为其容量可以在使用中动态变化。
#### 扩充的两种策略
●每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。
特点:节省空间，但是扩充操作频繁，操作次数多。
●每次扩充容量加倍，如每次扩充增加一倍存储空间。
特点:减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。

### 2.2.4 Python中的顺序表
Python中的Iist和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。
tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性
质类似。

** list的基本实现技术 **
Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的
顺序(即保序)，而且还具有以下行为特征:\
●基于下标(位置)的高效元素访问和更新，时间复杂度应该是0(1);
为满足该特征，应该采用顺序表技术,表中元素保存在一块连续的存储区中。\
●允许任意加入元素，而且在不断加入元素的过程中，表对象的标识(函数id得到的值)不变。\
为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分
离式实现技术。\
在Python的官方实现中，**list就是一种采用分离式技术实现的动态顺序表。** 这就是为什么用list.append(x)
(或list.insert(len(ist), x)，即尾部插入)比在指定位置插入元素效率高的原因。\
在Python的官方实现中，list实现采用了如下的策略:在建立空表(或者很小的表)时，系统分配-块能容纳
8个元素的存储区;在执行插入操作(insert或append) 时，如果元素存储区满就换-块4倍大的存储区。 但
如果此时的表已经很大( 目前的阀值为50000)，则改变策略，采用加一倍的方法。引入这种改变策略的方
式，是为了避免出现过多空闲的存储位置。

## 3链表
